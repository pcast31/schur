# weak_schur.py

This is a description of all the files in weak_schur.py, most notably, the `Partition` class. 

* [0. Running the code](#0-running-the-code)
* [1. Structure of each partition](#1-structure-of-each-partition)
* [2. Fitness and verify-partition](#2-fitness-and-verify-partition)
* [3. class Partition](#3-class-partition)
* [4. generate-partition](#4-generate-partition)

## 0. Running the code 

Running the test suite can be done using 
```bash 
$ pytest src/test.py
```
from the parent directory. Running the `test_compare_generate_partition` can be done using 
```bash 
$ pytest src/test.py::test_compare_generate_partition
```

Running [`weak_schur.py`](src/weak_schur.py) will currently prompt you for the number upto which we partition, and the number of colors to use. Then, the user can choose to use the naive or the iterative algorithms.

__**Note**__ The iterative algorithm is quite a bit faster :)


## 1. Structure of each partition

All partitions, even the instances of the `Partition` class have the same internal structure: `list[list[int]]`. `Partition` instances essentially combine a partition, its fitness and a method to calculate it.

## 2. Fitness and verify-partition

Fitness is the function that counts how many triples `(a,b,c)` exist in the given partition (read: `list[list[int]]`) such that `a+b = c`. `verify_fitness` only tells us if there is at least one such pair i.e. if the partition is weakly sum-free or not.

These two functions are based on the same idea (=> mostly the same code). 
For each sub-set in the partition, 
1. They create a Cartesian product of the set with itself (`np.meshgrid`), 
2. take the strictly triangular part (since each pair `(a,b)` is equivalent to `(b,a)`), 
3. and compute the sum of each such pair.
    - The `fitness` function counts the results that are in the current subpartition, i.e. how many times `a+b` belongs to the current sub-partition.
    - The `verify_fitness` function checks if any sum belongs to the current sub-partition, and returns `False` if there is at least one, else `True`.
4. Finally, `fitness` will sum the score of each sub-partition to give the score of the entire partition.

## 3. class Partition

```python 
class Partition: 
    partition: list[list[int]]
    score: int 

    def single_add(self, elem: int, color: int) -> bool: 
        ... 
    def count_difference(self, elem: int, color: int) -> int: 
        ...
    def count_sum(self, elem: int, color: int) -> int: 
        ...
```

The single_add function takes an element to add (`elem`), a sub-partition to add it to (`color`), and adds it. It also updates the `score` of the partition, using only the pairs generated by adding `elem`, assuming the score before addition was correct.

This iterative addition is based on the observation that when we add `elem` to `partition[color] : list[int]`, only two types of pairs are generated: 1. `a + b = elem` and/or 2. `a + elem = b`. 

- `count_sum` counts Type 1 using the simplification `elem - b = a`, and checks if for all `b`, does `(elem - b)` belong to `partition[color]`.
- `count_difference` counts Type 2 using the simplification `b - elem = a`, and checks if for all `b`, does `(b - elem)` belong to `partition[color]`.

These are both linear operations, as currently implemented using hashmaps. Both of these functions return the counts, BUT DO NOT UPDATE THE INTERNAL SCORE! This is left for any calling function to integrate on its own, making these methods fairly general and easy to use elsewhere. Currently, `single_add` does this, as it should.

## 4. generate-partition

This currently implements the greedy, naive algorithm without any parallelisation. It works, and is reasonably fast, but still depends on the classical `fitness`. 

`generate_fitness_iterative` uses the iterative method and is considerably faster, since it represents an linear vs. quadratic buildup. Primitive results can be seen from the logfile [results/test_compare_generate_partition.txt](../results/test_compare_generate_partition.txt)
